## 29. Génération automatique de cas de test logiciel par contraintes  
**Description :** Pour tester un programme, on cherche souvent des jeux de données d’entrée qui forcent l’exécution de certains chemins ou scénarios (par exemple, couvrir toutes les branches d’un code critique). Le problème peut se formuler ainsi : **trouver une entrée** (ou une séquence d’appels) telle qu’une condition donnée soit vraie à un point du programme (par ex. atteindre une ligne de code particulière, ou violer une assertion pour détecter un bug). Au lieu de deviner à la main, on peut utiliser une technique de *génération de tests par contraintes*, connue aussi sous le nom d’**exécution symbolique**. On exécute le programme en symbolique, c’est-à-dire en accumulant des contraintes logiques sur les variables d’entrée le long des chemins, et on utilise un solveur de contraintes pour obtenir des valeurs concrètes satisfaisant ces contrainte ([[PDF] KLEE: Unassisted and Automatic Generation of High-Coverage ...](https://hci.stanford.edu/cstr/reports/2008-03.pdf#:~:text=,For))】. Par exemple, pour tester une fonction triant un tableau, on peut demander un cas où `array[0] > array[1]` à la fin (erreur potentielle), le moteur symbolique extraira les contraintes reliant les entrées à cet état et le solveur donnera un tableau d’entiers effectif réalisant cela.  

**Intérêt de l’approche CSP :** Cette méthode automatise la génération de tests avec une **couverture élevée et ciblée**. En effet, le solveur va systématiquement tenter de satisfaire la condition d’intérêt en explorant l’espace d’entrée, et s’il y a une solution il la trouvera (et sinon on a la quasi-certitude qu’aucune entrée ne provoque ce scénario). L’outil **KLEE** a par exemple montré qu’il pouvait générer automatiquement des tests couvrant la plupart des chemins d’utilitaires Unix complexe ([KLEE: Unassisted and Automatic Generation of High-Coverage ...](https://www.usenix.org/legacyurl/klee-unassisted-and-automatic-generation-high-coverage-tests-complex-systems-programs-0#:~:text=KLEE%3A%20Unassisted%20and%20Automatic%20Generation,set%20of%20complex%20and))】. L’utilisation de solveurs de contraintes garantit aussi que les tests générés sont pertinents : pas de faux positifs, on trouve des entrées concrètes qui réalisent précisément le chemin voul ([[PDF] KLEE: Unassisted and Automatic Generation of High-Coverage ...](https://hci.stanford.edu/cstr/reports/2008-03.pdf#:~:text=,For))】. Par rapport à des méthodes fuzz aléatoires, on explore de manière plus **intelligente** : chaque branche du programme engendre une contrainte (ex. si on prend le branche *then*, on ajoute la contrainte conditionnelle correspondante), puis on résout pour sortir des valeurs. Ainsi on peut couvrir des branches difficiles d’accès nécessitant des combinaisons spécifiques de conditions. De plus, cette approche permet de trouver des bugs subtils et d’**explorer les limites** (dépassements d’entier, division par zéro, etc.) en formulant ces erreurs comme des contraintes à réaliser. De nombreux frameworks de test modernes (Microsoft SAGE, KLEE, etc.) intègrent de tels solveurs SMT pour améliorer la portée des tests logiciels.  

**Références :** *Cadar et al.*, **KLEE (Automatic High-Coverage Tests)* ([[PDF] KLEE: Unassisted and Automatic Generation of High-Coverage ...](https://hci.stanford.edu/cstr/reports/2008-03.pdf#:~:text=,For))】 – KLEE utilise un solveur de contraintes pour déterminer un ensemble concret de valeurs d’entrée satisfaisant les contraintes d’exécution d’un chemin, qu’il exporte en tant que cas de test. *Patrice Godefroid et al., DART (PLDI’05)* – introduit le concept d’exécution dirigée par contraintes pour générer des tests, combinant exécution concrète et symbolique. *Blog « VerificationGlasses » ([10. Automated test generation using symbolic execution](https://swen90006.github.io/Symbolic-Execution.html#:~:text=Next%2C%20we%20use%20a%20constraint,input%20for%20the%20path))】 – tutoriel sur la génération de tests avec KLEE, expliquant comment un **path constraint** est converti en un input réel via un SMT solver, démontrant la puissance de l’approche pour atteindre des branches spécifiques du code.  
